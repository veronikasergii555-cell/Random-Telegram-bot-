<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Капча-игра: распределите фрукты по корзинкам</title>
<style>
  /* ---------------------------
     Acceptance tests (проверьте вручную):
     1. Открыв страницу — фон чёрный, по центру полупрозрачный белый квадрат с заголовком "Распредели фрукты по корзинкам".
     2. В верхней части внутри квадрата — прямоугольник с 3 корзинками, над каждой корзинкой — соответствующий фрукт.
     3. В игровой зоне — 5 фруктов (2 яблока, 2 ананаса, 1 вишня) расположенных случайно.
     4. Drag (мышь) и touch (тач) работают: при наведении корзинка подсвечивается; отпускание над корзинкой делает фрукт исчезающим.
     5. Отпускание не над корзинкой — фрукт плавно возвращается на место.
     6. После размещения всех 5 фруктов — overlay "WIN" появляется.
     7. Всё — в одном файле, без внешних ресурсов.
     --------------------------- */
  :root{
    --bg:#000;
    --panel-bg: rgba(255,255,255,0.95);
    --panel-radius:14px;
    --panel-padding:16px;
    --muted: rgba(0,0,0,0.6);
    --drop-highlight: 0 6px 18px rgba(0,150,255,0.25);
    --success-color: #21c87a;
  }
  html,body{height:100%;background:var(--bg);margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .center{
    min-height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:20px;
    box-sizing:border-box;
  }
  .panel{
    width:90vw;
    max-width:460px;
    background:var(--panel-bg);
    border-radius:var(--panel-radius);
    padding:var(--panel-padding);
    box-sizing:border-box;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    position:relative;
    touch-action:none; /* we'll manage pointer events */
  }
  h1{
    margin:6px 0 12px;
    font-size:18px;
    text-align:center;
    color:#111;
    font-weight:600;
  }

  /* area with baskets */
  .baskets-area{
    background: rgba(0,0,0,0.04);
    border-radius:10px;
    padding:12px;
    display:flex;
    justify-content:space-between;
    gap:8px;
    align-items:end;
    margin-bottom:12px;
  }
  .basket-slot{
    width:30%;
    aspect-ratio:1/1;
    background: rgba(255,255,255,0.02);
    border-radius:8px;
    display:flex;
    align-items:end;
    justify-content:center;
    position:relative;
    transition: transform 150ms ease, box-shadow 150ms ease;
    box-sizing:border-box;
    padding-bottom:8px;
  }
  .basket-slot.highlight{ transform: translateY(-6px) scale(1.03); box-shadow: var(--drop-highlight); }
  .basket-slot svg{ width:56%; height:auto; display:block; pointer-events:none; }

  .basket-label{
    position:absolute;
    top:8px;
    left:50%;
    transform:translateX(-50%);
    font-size:12px;
    color:#222;
    pointer-events:none;
  }

  /* game field */
  .field{
    height:280px;
    border-radius:8px;
    background: rgba(0,0,0,0.02);
    position:relative;
    overflow:hidden;
    touch-action:none;
  }

  /* fruit items */
  .fruit{
    position:absolute;
    width:56px;
    height:56px;
    touch-action:none; /* prevent default scrolling on touch move */
    user-select:none;
    cursor:grab;
    transition: transform 320ms cubic-bezier(.2,.9,.2,1);
    will-change:transform;
  }
  .fruit:active{ cursor:grabbing; }
  .fruit.placed{ opacity:0; transform: scale(.3) translateY(10px); pointer-events:none; transition: opacity 260ms ease, transform 260ms ease; }
  .fruit svg{ width:100%; height:100%; display:block; pointer-events:none; }

  /* selected state for click-to-place */
  .fruit.selected{ outline:3px solid rgba(0,150,255,0.18); border-radius:8px; transform:scale(1.05); }

  /* overlay WIN */
  .overlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.6);
    color:white;
    font-size:56px;
    font-weight:800;
    z-index:999;
    pointer-events:none;
    opacity:0;
    transform:scale(.98);
    transition:opacity 300ms ease, transform 300ms ease;
  }
  .overlay.show{ opacity:1; transform:scale(1); pointer-events:auto; }

  .controls{
    display:flex;
    gap:8px;
    justify-content:center;
    margin-top:12px;
  }
  .btn{
    background:transparent;
    border:1px solid rgba(0,0,0,0.08);
    padding:8px 12px;
    border-radius:8px;
    font-size:14px;
    cursor:pointer;
  }
  .btn:active{ transform:translateY(1px); }

  /* responsive tweaks */
  @media (max-width:420px){
    .fruit{ width:48px; height:48px; }
    .field{ height:220px; }
    .basket-slot svg{ width:62%; }
  }
</style>
</head>
<body>
<div class="center">
  <div class="panel" role="application" aria-label="Капча: игра - распределите фрукты">
    <h1>Распредели фрукты по корзинкам</h1>

    <div class="baskets-area" aria-hidden="false">
      <!-- Three baskets: apple, cherry, pineapple -->
      <div class="basket-slot" data-type="apple" role="button" aria-label="Корзинка для яблок" tabindex="0">
        <div class="basket-label">Яблоко</div>
        <!-- apple basket svg -->
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <g fill="none" stroke="#6b4f2b" stroke-width="2">
            <path d="M10 34c0 0 5-16 22-16s22 16 22 16v10H10V34z" fill="#cfa77a" stroke="#7a5130"/>
            <rect x="8" y="30" width="48" height="8" rx="2" fill="#7a5130"/>
          </g>
        </svg>
      </div>

      <div class="basket-slot" data-type="cherry" role="button" aria-label="Корзинка для вишен" tabindex="0">
        <div class="basket-label">Вишня</div>
        <!-- cherry basket svg -->
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <g fill="none" stroke="#5a3f2a" stroke-width="2">
            <path d="M10 34c0 0 6-12 22-12s22 12 22 12v10H10V34z" fill="#b8865a" stroke="#5a3f2a"/>
            <rect x="14" y="30" width="36" height="6" rx="2" fill="#5a3f2a"/>
          </g>
        </svg>
      </div>

      <div class="basket-slot" data-type="pineapple" role="button" aria-label="Корзинка для ананасов" tabindex="0">
        <div class="basket-label">Ананас</div>
        <!-- pineapple basket svg -->
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <g fill="none" stroke="#6b4f2a" stroke-width="2">
            <path d="M10 34c0 0 4-14 22-14s22 14 22 14v10H10V34z" fill="#caa87f" stroke="#6b4f2a"/>
            <rect x="10" y="30" width="44" height="8" rx="2" fill="#6b4f2a"/>
          </g>
        </svg>
      </div>
    </div>

    <div class="field" id="field" aria-label="Игровое поле">
      <!-- fruits will be injected here -->
    </div>

    <div class="controls" aria-hidden="false">
      <button id="restart" class="btn" aria-label="Перезапустить игру">Перезапустить</button>
    </div>

  </div>
</div>

<div id="overlay" class="overlay" role="status" aria-live="polite" aria-hidden="true">WIN</div>

<script>
/* ---------------------------
   JS: игровой движок капчи
   - Поддержка pointer events (работает для мыши и touch)
   - Click-to-place fallback (тап → тап по корзинке)
   - Inline SVG используются для графики
   - Комментарии к ключевым местам
   --------------------------- */

(function(){
  // Конфигурация фруктов: 2 яблока, 2 ананаса, 1 вишня
  const FRUITS = [
    {type:'apple'}, {type:'apple'},
    {type:'pineapple'}, {type:'pineapple'},
    {type:'cherry'}
  ];

  const field = document.getElementById('field');
  const basketSlots = Array.from(document.querySelectorAll('.basket-slot'));
  const overlay = document.getElementById('overlay');
  const restartBtn = document.getElementById('restart');

  let fruitsState = []; // {el, type, start:{x,y}, placed:boolean}
  let placedCount = 0;
  let activeDrag = null; // {el, id, offsetX, offsetY, startX,startY}
  let selectedForClick = null; // для tap-to-place

  /* -------------------------
     SVG генератор фруктов (return element)
     ------------------------- */
  function makeFruitSVG(type){
    const ns = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(ns,'svg');
    svg.setAttribute('viewBox','0 0 64 64');
    svg.setAttribute('aria-hidden','true');

    if(type==='apple'){
      svg.innerHTML = `
        <g>
          <circle cx="32" cy="34" r="14" fill="#ff5a5a" stroke="#a02b2b" stroke-width="2"/>
          <path d="M34 16c1 3-4 6-5 1" stroke="#2a6a2a" stroke-width="2" fill="none"/>
          <rect x="30" y="12" width="4" height="6" rx="1" fill="#6a4" transform="rotate(-20 32 15)"/>
        </g>`;
    } else if(type==='cherry'){
      svg.innerHTML = `
        <g>
          <circle cx="22" cy="36" r="10" fill="#d32b55" stroke="#7a102a" stroke-width="2"/>
          <circle cx="42" cy="36" r="10" fill="#d32b55" stroke="#7a102a" stroke-width="2"/>
          <path d="M29 28 C32 20, 36 20, 39 28" stroke="#3a2b10" stroke-width="2" fill="none"/>
        </g>`;
    } else if(type==='pineapple'){
      svg.innerHTML = `
        <g>
          <ellipse cx="32" cy="36" rx="12" ry="18" fill="#f5d36b" stroke="#9c6b2d" stroke-width="2"/>
          <path d="M20 24 L28 16 L36 16 L44 24" fill="#8fcf55" stroke="#6ba044" stroke-width="1.5"/>
          <g stroke="#b98f2e" stroke-width="1">
            <path d="M24 26 l4 4 M28 26 l-4 4 M36 28 l4 4 M32 30 l4 -4"/>
          </g>
        </g>`;
    }
    return svg;
  }

  /* -------------------------
     Создаёт DOM-элемент фрукта
     ------------------------- */
  function createFruitEl(type, id){
    const el = document.createElement('div');
    el.className = 'fruit';
    el.dataset.type = type;
    el.dataset.id = id;
    el.setAttribute('role','button');
    el.setAttribute('aria-label', `Фрукт ${type}`);
    el.appendChild(makeFruitSVG(type));
    return el;
  }

  /* -------------------------
     Старайтесь минимизировать перекрытия при генерации случайных позиций.
     Пробуем случайные точки и проверяем расстояния к уже размещённым.
     ------------------------- */
  function randomPositions(count, fieldRect, itemSize){
    const positions = [];
    const padding = 8;
    const maxAttempts = 500;
    for(let i=0;i<count;i++){
      let attempts = 0;
      let ok=false;
      while(attempts < maxAttempts && !ok){
        attempts++;
        const x = Math.round(Math.random()*(fieldRect.width - itemSize - padding*2)) + padding;
        const y = Math.round(Math.random()*(fieldRect.height - itemSize - padding*2)) + padding;
        ok = true;
        for(const p of positions){
          const dx = p.x - x;
          const dy = p.y - y;
          const dist = Math.hypot(dx,dy);
          if(dist < itemSize * 0.9) { ok = false; break; } // слишком близко
        }
        if(ok) positions.push({x,y});
      }
      if(!ok){
        // fallback: place sequentially
        positions.push({x: padding + i*(itemSize+8) % Math.max(1,fieldRect.width-itemSize), y: padding + Math.floor(i/5)* (itemSize+8)});
      }
    }
    return positions;
  }

  /* -------------------------
     Инициализация игры: создаём элементы фруктов и ставим рандомно
     ------------------------- */
  function startGame(){
    // очистка
    field.innerHTML = '';
    fruitsState = [];
    placedCount = 0;
    overlay.classList.remove('show');
    overlay.setAttribute('aria-hidden','true');
    selectedForClick = null;
    activeDrag = null;

    // создаём элементы для фруктов
    const fieldRect = field.getBoundingClientRect();
    const itemSize = Math.min(56, Math.round(fieldRect.width * 0.13));
    const positions = randomPositions(FRUITS.length, fieldRect, itemSize);

    FRUITS.forEach((info, idx) => {
      const el = createFruitEl(info.type, idx);
      // set size based on itemSize but keep CSS rule as default
      el.style.width = itemSize + 'px';
      el.style.height = itemSize + 'px';
      // initial pos
      const pos = positions[idx];
      el.style.left = pos.x + 'px';
      el.style.top = pos.y + 'px';
      // store state
      fruitsState.push({
        id: idx,
        el,
        type: info.type,
        start: {x: pos.x, y: pos.y},
        placed: false
      });
      field.appendChild(el);
      bindFruitEvents(el);
    });
  }

  /* -------------------------
     Биндим pointer + click/tap события на фрукты
     ------------------------- */
  function bindFruitEvents(el){
    // Pointer events for drag
    el.addEventListener('pointerdown', onPointerDown);
    // Prevent default touch actions at the field level where necessary
    el.addEventListener('dragstart', e=>e.preventDefault());
    // Click/tap to select for click-to-place
    el.addEventListener('click', (e)=>{
      // if currently dragging, ignore
      if(activeDrag) return;
      // toggle selection
      if(selectedForClick && selectedForClick !== el) {
        selectedForClick.classList.remove('selected');
      }
      if(el.classList.contains('selected')){
        el.classList.remove('selected');
        selectedForClick = null;
      } else {
        el.classList.add('selected');
        selectedForClick = el;
      }
    });
  }

  /* -------------------------
     Pointer down handler
     ------------------------- */
  function onPointerDown(e){
    // left button only (button === 0) but for touch it's -1/undefined; accept everything except right-click
    if(e.button === 2) return;
    const el = e.currentTarget;
    // ignore if already placed
    if(el.classList.contains('placed')) return;

    // capture pointer
    el.setPointerCapture && el.setPointerCapture(e.pointerId);
    const rect = el.getBoundingClientRect();
    const fieldRect = field.getBoundingClientRect();

    activeDrag = {
      el,
      id: e.pointerId,
      offsetX: e.clientX - rect.left,
      offsetY: e.clientY - rect.top,
      startX: rect.left - fieldRect.left,
      startY: rect.top - fieldRect.top
    };

    // make sure transitions are off while dragging for snappy movement
    el.style.transition = 'none';
    el.style.zIndex = 1000;

    // subscribe move and up on window (to capture even if pointer leaves element)
    window.addEventListener('pointermove', onPointerMove);
    window.addEventListener('pointerup', onPointerUp,{once:true});
    window.addEventListener('pointercancel', onPointerUp,{once:true});

    e.preventDefault();
  }

  /* -------------------------
     Pointer move: update position using CSS transform for performance
     ------------------------- */
  function onPointerMove(e){
    if(!activeDrag || e.pointerId !== activeDrag.id) return;
    const el = activeDrag.el;
    const fieldRect = field.getBoundingClientRect();
    const x = e.clientX - fieldRect.left - activeDrag.offsetX;
    const y = e.clientY - fieldRect.top - activeDrag.offsetY;

    // clamp to field
    const maxX = fieldRect.width - el.offsetWidth;
    const maxY = fieldRect.height - el.offsetHeight;
    const clampedX = Math.max(0, Math.min(maxX, x));
    const clampedY = Math.max(0, Math.min(maxY, y));

    // move element visually
    el.style.transform = `translate(${clampedX - activeDrag.startX}px, ${clampedY - activeDrag.startY}px)`;

    // check highlight for baskets
    const fruitCenter = { x: clampedX + el.offsetWidth/2 + fieldRect.left, y: clampedY + el.offsetHeight/2 + fieldRect.top };
    updateBasketHighlights(fruitCenter, el.dataset.type);
  }

  /* -------------------------
     Pointer up: perform drop test
     ------------------------- */
  function onPointerUp(e){
    if(!activeDrag) return;
    const el = activeDrag.el;
    // release pointer capture
    try{ el.releasePointerCapture && el.releasePointerCapture(activeDrag.id); } catch(_){}
    // restore transition
    el.style.transition = 'transform 320ms cubic-bezier(.2,.9,.2,1)';
    el.style.zIndex = '';

    // compute current position relative to field
    const fieldRect = field.getBoundingClientRect();
    // position derived from transform
    const matrix = window.getComputedStyle(el).transform;
    let dx = 0, dy = 0;
    if(matrix && matrix !== 'none') {
      const vals = matrix.match(/matrix.*\((.+)\)/)[1].split(',').map(Number);
      dx = vals[4]; dy = vals[5];
    }
    const currentX = activeDrag.startX + dx;
    const currentY = activeDrag.startY + dy;

    // find basket under center
    const fruitCenter = { x: currentX + el.offsetWidth/2 + fieldRect.left, y: currentY + el.offsetHeight/2 + fieldRect.top };
    const targetBasket = findBasketUnderPoint(fruitCenter);

    if(targetBasket && targetBasket.dataset.type === el.dataset.type){
      // successful drop
      placeFruit(el, targetBasket);
    } else {
      // return to start
      resetFruitPosition(el);
    }

    // clear highlights
    clearBasketHighlights();

    // cleanup listeners
    window.removeEventListener('pointermove', onPointerMove);
    activeDrag = null;
  }

  /* -------------------------
     Find basket element under a screen point (x,y)
     ------------------------- */
  function findBasketUnderPoint(point){
    for(const slot of basketSlots){
      const r = slot.getBoundingClientRect();
      if(point.x >= r.left && point.x <= r.right && point.y >= r.top && point.y <= r.bottom){
        return slot;
      }
    }
    return null;
  }

  /* -------------------------
     Update basket highlight when fruit is near/over
     ------------------------- */
  function updateBasketHighlights(centerPoint, fruitType){
    let any = false;
    for(const slot of basketSlots){
      const r = slot.getBoundingClientRect();
      // simple overlap test: center point inside rect
      const inside = centerPoint.x >= r.left && centerPoint.x <= r.right && centerPoint.y >= r.top && centerPoint.y <= r.bottom;
      if(inside && slot.dataset.type === fruitType){
        slot.classList.add('highlight');
        any = true;
      } else {
        slot.classList.remove('highlight');
      }
    }
    return any;
  }

  function clearBasketHighlights(){
    basketSlots.forEach(s=>s.classList.remove('highlight'));
  }

  /* -------------------------
     Place fruit into basket (correct)
     ------------------------- */
  function placeFruit(el, basketEl){
    // mark placed visually + logically
    el.classList.add('placed');
    const id = Number(el.dataset.id);
    const state = fruitsState.find(f=>f.id===id);
    if(state) state.placed = true;
    placedCount++;
    // small success animation on basket
    basketEl.animate([{ transform: 'scale(1)' }, { transform: 'scale(1.06)' }, { transform: 'scale(1)'}], { duration:220 });
    // after animation remove element from DOM to avoid confusion (but keep placed flag)
    setTimeout(()=> {
      try { el.remove(); } catch(_) {}
      checkWin();
    }, 260);
    // unselect if it was selected for click-to-place
    if(selectedForClick === el){
      selectedForClick = null;
    }
  }

  /* -------------------------
     Reset fruit to its start position
     ------------------------- */
  function resetFruitPosition(el){
    el.style.transform = 'translate(0px,0px)';
    // unselect
    if(el.classList.contains('selected')){
      el.classList.remove('selected');
      selectedForClick = null;
    }
  }

  /* -------------------------
     Check win condition
     ------------------------- */
  function checkWin(){
    if(placedCount >= FRUITS.length){
      overlay.classList.add('show');
      overlay.setAttribute('aria-hidden','false');
    }
  }

  /* -------------------------
     Click-to-place: tap basket when a fruit is selected
     ------------------------- */
  basketSlots.forEach(slot=>{
    slot.addEventListener('click', e=>{
      // if there's a fruit selected by click
      if(!selectedForClick) return;
      const fruit = selectedForClick;
      // only allow matching types
      if(slot.dataset.type === fruit.dataset.type){
        placeFruit(fruit, slot);
      } else {
        // small shake to indicate wrong
        fruit.animate([{ transform:'translateX(0)' }, { transform:'translateX(-8px)' }, { transform:'translateX(6px)' }, { transform:'translateX(0)' }], { duration:260 });
      }
      // clear selection styling
      fruit.classList.remove('selected');
      selectedForClick = null;
    });

    // keyboard support: focus + Enter to place last selected fruit
    slot.addEventListener('keydown', (ev)=>{
      if(ev.key === 'Enter' && selectedForClick){
        slot.click();
      }
    });
  });

  // keyboard accessibility: allow selecting fruits with Tab and Enter
  // (fruits already have role=button)

  // restart handler
  restartBtn.addEventListener('click', startGame);

  // handle resize: recompute positions (simple approach: restart)
  let resizeTimer = null;
  window.addEventListener('resize', ()=>{
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=> startGame(), 220);
  });

  // initial start
  startGame();

  // expose some functions for debugging from console (optional)
  window.__captchaGame = {startGame};

})();
</script>
</body>
</html>
